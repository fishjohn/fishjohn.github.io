<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昊翔的个人站</title>
  
  <subtitle>日拱一卒，功不唐捐</subtitle>
  <link href="http://luohaoxiang.xyz/atom.xml" rel="self"/>
  
  <link href="http://luohaoxiang.xyz/"/>
  <updated>2021-10-13T12:07:05.213Z</updated>
  <id>http://luohaoxiang.xyz/</id>
  
  <author>
    <name>昊翔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021年华为嵌入式软件大赛--算法组</title>
    <link href="http://luohaoxiang.xyz/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/"/>
    <id>http://luohaoxiang.xyz/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/</id>
    <published>2021-08-12T13:19:00.000Z</published>
    <updated>2021-10-13T12:07:05.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">0.前言</h2><p>本文记录了正经队在2021年华为嵌入式软件大赛--算法组中的代码思路。在此比赛中解决的是星际光通信网络中的卫星位置规划问题。</p><span id="more"></span><h2 id="赛题解析">1. 赛题解析</h2><p>赛题详情请参看赛题任务书，以下简要对赛题做分析解读。</p><h3 id="输入">1.1 输入</h3><ol type="1"><li><p><strong>节点</strong></p><p>此赛题的输入为一个给定的卫星网络连接图，分为<strong>基地</strong>和<strong>卫星</strong>两类站点：</p><ul><li>基地：作为网络图的起点</li><li>卫星：<ul><li>中转卫星：中转节点</li><li>接收卫星：作为网络图的终点</li></ul></li></ul></li><li><p><strong>功耗</strong></p><ul><li>路径功耗：与距离成线性相关</li><li>建站功耗：每颗接收卫星的功耗</li></ul></li><li><p><strong>约束条件</strong></p><ul><li>路径重合约束：不同的接收卫星与其覆盖的基地的路径不得重合</li><li>路径长度约束：发射基站经过中转卫星到接收卫星路径总长度需满足最大路径长度约束</li></ul></li></ol><p>输入图样例如下：</p><p><img src="/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/卫星连接图输入图示.png" style="zoom:80%;"></p><p>从上图可以看出，蓝色虚线和红色虚线分别代表了两颗接收卫星到其管理的基站的路径，相同颜色的路径代表同一业务，蓝色路径表示了0号卫星是5、6、7、8号基地的接收卫星，红色路径表示了1号卫星是9、10的接收卫星，不同的接收卫星业务不同，路径不能交叉（例如上图中蓝色路径和红色路径不允许重合），但是可以经过相同的中转卫星，如图中3号卫星。</p><h3 id="目标">1.2目标</h3><ol type="1"><li>所有基站都要有且仅有一个接收卫星管理，并给出所有发射基站到管理它的接收卫星的路径</li><li>得出解满足所有约束条件</li><li>通过规划，使得网络总功耗最低，即路径尽可能短、建站尽可能少（初赛）</li></ol><h2 id="整体思路">2. 整体思路</h2><p>我们首先根据给定的基站和卫星网络连接图，对每颗卫星，都使用Dijkstra算法，确定其到每座基地的最短路径，并统计每个卫星-基地连接的最短路径的路径长度，将满足路径长度约束的卫星和基地连接加入到一个二部图中，即可知道将哪些卫星作为接收卫星可以“覆盖”到哪些基地，对于得到的二部图，我们需要在其中找出一个接收卫星集合解，能保证覆盖所有的基站，并且力图让总功耗最低（初赛为例：总功耗=建站功耗+路径功耗），因此我们使用到了蚁群算法，蚁群算法是一种启发式算法，蚁群中的每只蚂蚁会在信息素和启发式因素的影响下选择接收卫星，每只蚂蚁会得到一个接收卫星集合，经过不断地迭代优化，总功耗最低的接收卫星集合解会保留下来，在这个集合解中，我们为每一个基地选择最近的卫星作为接收卫星，再用一个特殊规则的数组解析出每条输出路径。</p><h2 id="二部图">3. 二部图</h2><p>为了将输入图简化，我们引入一个二部图，该二部图的两顶点分别代表基地和接收卫星，边代表基地和接收卫星的路径，边的权值为路径长度，两侧顶点间当且仅当路径长度小于等于最大长度限制时有连线。</p>对于赛题输入的基站和卫星网络连接图，我们使用了<a href="https://blog.csdn.net/weixin_44316314/article/details/89854209">Dijkstra算法</a>计算每颗卫星到达基站的最短路径，若最短路径满足路径长度约束，<strong>即此卫星能覆盖到此基地</strong>，则将这一对卫星-基地连接加入到二部图中，二部图的图示样例如下：<div data-align="center"><img src="/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/bGraph连接示意图.jpg" style="zoom:120%;"></div><p>如上图所示，显而易见，我们需要解决的问题就是选择卫星组合，保证所有的基地都能被覆盖，并且尽可能地追求卫星组合所消耗的功率最小，此问题即转化为<strong>集合覆盖问题（SCP）</strong></p><h2 id="蚁群算法解决scp">4. 蚁群算法解决SCP</h2>集合覆盖问题是典型的组合优化问题，如上的图中，我们需要找到一个接收卫星的组合，以覆盖所有的基地，并且要求这个组合的总功耗最小，渴望得到一个“最优解”，我们有几种思路呢？<div data-align="center"><img src="/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/SCP数学模型.png" style="zoom:80%;"></div><ol type="1"><li><p><strong>穷举法</strong></p><p>在数学模型上，我们将选中的卫星标记为1，未选中的卫星标记为0，可以穷举不同的解的组合并计算其功耗，在卫星和基地数量有限的情况下，必然能找出一个最优解，但是时间复杂度非常感人，数据集中卫星基地总数在四位数以上，赛题要求在单线程条件下5分钟内求出结果，此法不应在比赛中使用。</p></li><li><p><strong>贪心算法</strong></p><p>贪心算法思想是下一步的利益最大化，在此问题中贪的是卫星覆盖基地数，即在基地未被完全覆盖时，总是选择下一个能覆盖最多的未被覆盖基地的卫星，伪代码如下 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(所有基地未被完全覆盖)&#123;</span><br><span class="line">此次循环选中卫星 :&#x3D; 能覆盖最多的未被覆盖基地的卫星</span><br><span class="line">Insert 此次循环选中卫星</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其实我们还可以将贪心算法改进一下，我们将比较成分从新覆盖基地数newCoverNums替换成如下计算公式求得的权重：</p><center><p>weight = newCoverNums/(SumDists * coeff + Psite)</p></center><p>因为我们期望选出总功耗更小、覆盖新基地数更多的卫星。但是众所周知，贪心算法可以得到一个大体满意的可行解，但往往不是最优解，如以下情况：</p><div data-align="center"><img src="/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/贪心算法失败举例.png" style="zoom:80%;"></div><p>根据上述贪心算法，我们第一步会先选择新覆盖基地数最多的S2或是S3(皆为6个新覆盖基地数)中的一个集合，选择它们两个中总功耗更少的一位，即{S2}或{S3}，再执行一轮上述算法，得解的组合{S2,S4}或{S3,S1}，但我们不能保证第一步最优的解在第二步执行之后还是最优的，因为假设第一步选择{S2}优于{S3},但是选择{S3,S1}的组合可能会优于{S2,S4},因此贪心算法不能保证得到的结果是最优解。</p></li><li><p><strong>蚁群算法</strong></p><p>蚁群算法来源于蚂蚁在寻找食物过程中发现最短路径的行为。我们将上述集合覆盖问题的解抽象成蚁群寻找最短路径，蚁群搜寻的过程是一系列的迭代，在每一次迭代中，每一只蚂蚁都在信息素和启发式因素的指导下进行搜索、构建解，在一轮迭代过后，会根据本轮迭代的最优结果更新信息素，因此在下一次迭代中，就会在这一块“可靠”的区域继续优化，寻找一个更优的解，当达到迭代次数上限或运行时间超过上限值时，算法停止。 下面介绍一下每只蚂蚁运行的过程：</p><ol type="1"><li>若基地集合未被完全覆盖，<strong>随机</strong>（为了保证搜索的发散性）选取一颗基地base，否则转入步骤3</li><li>为选中的基地选择一颗接收卫星<ul><li>通过二部图的邻接表获得能覆盖选中基地的卫星列表，得到候选卫星集合</li><li>为每颗候选卫星计算被选中的概率</li><li>轮盘赌法，决定哪颗卫星作为选中基地的接收卫星</li><li>将选中的卫星插入接收卫星（解）的列表，更新未覆盖基地集合，返回步骤1</li></ul></li><li>local search: 删除冗余的卫星，由于步骤1中选择基地的顺序是随机的，可能导致出现冗余卫星的情况，如下图，删除2号卫星可以解仍然可行，则2号卫星是冗余的，我们需将冗余的卫星从集合解中删除</li></ol></li></ol><div data-align="center"><img src="/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/卫星冗余示意图.jpg" style="zoom:100%;"></div><p>比较关键的一步是步骤2中为每颗候选卫星计算被选中的概率，此概率决定了在轮盘赌中，哪颗卫星更有机会被选中为该基地的接收卫星，概率的计算公式如下：</p><div data-align="center"><img src="/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/概率计算公式.png" style="zoom:100%;"></div><p>上式的<span class="math inline">\(\tau\)</span>代表信息素浓度，<span class="math inline">\({\eta}\)</span>代表启发式函数值，<span class="math inline">\({\alpha}\)</span>和<span class="math inline">\({\beta}\)</span>分别是其对应指数，信息素浓度是整个蚁群的经验积累，而启发函数值是每只蚂蚁在搜寻时选择一颗卫星作为接收卫星能够新增的基地覆盖数（注意启发函数不是目标函数，如果将启发函数设定为目标函数，整个蚁群的搜素很容易就陷入了局部最优而失去了发散性）。</p><p>在每轮迭代过后，每一只蚂蚁都构建了一个完整的解，为了让蚂蚁忘却部分的历史经验，我们需要模拟信息素挥发，然后蚂蚁在最优解决方案所包含的列沉淀信息素（注意是历史最优解），为了防止搜索停滞，信息素浓度范围应控制在 [<span class="math inline">\(\tau_{min}\)</span>,<span class="math inline">\(\tau_{max}\)</span>],更新规则如下：</p><div data-align="center"><img src="/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/信息素更新规则公式.png" style="zoom:100%;"></div><p>以上公式中<span class="math inline">\(\rho\)</span>是信息素挥发因子，取值范围[0,1]，<span class="math inline">\(\Delta\tau_j\)</span>等于最优解决方案功耗的倒数。</p><h2 id="结果输出">5. 结果输出</h2><p>由以上蚁群算法的迭代过后，我们可以获得一个较优的接收卫星集合，由于在二部图中，边代表的仅仅是接收卫星和基地抽象的连接，不是一条完整的具体路径，因此还要在初始输入的网络图中解析出基地到接收卫星的路径当作结果输出。</p><p>在此先介绍一下我们是如何存储路径的，如下的一个网络图，1号卫星是2号基地和9号基地的接收卫星。</p><div data-align="center"><img src="/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/last网络图示.png" style="zoom:100%;"></div><p>我们创建了一个数组，数组的大小就是所有节点的数量（基地+卫星），数组的索引号为节点ID，值为该节点的上一个节点ID，末端节点在数组中的元素值为自身的ID，即“自己指向自己”，将以上网络图转换为数组存储为：</p><table><thead><tr class="header"><th style="text-align: center;">索引号</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th><th style="text-align: center;">8</th><th style="text-align: center;">9</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">元素值</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">8</td></tr></tbody></table><p>我们称上述数据结构为last，在得到一个卫星集合解后，为获得指定输出的路径信息，我们经历了以下步骤：</p><ol type="1"><li>将具体路径存入last<ul><li>在接收卫星集合解中为每颗基地选择最邻近的接收卫星</li><li>用Dijkstra算法求得该卫星到基地的最短路径并且将路径节点存入last</li></ul></li><li>从每个基地出发，递归读取last，即得到所有的输出路径</li></ol><h2 id="qa">6. Q&amp;A</h2><ol type="1"><li><p><strong>为什么用蚁群算法求出的卫星集合解可以满足路径长度约束？</strong></p><p>因为我们在构造二部图时，加入的边的前提条件就是必须满足路径长度约束的基地-接收卫星连接，在二部图中为每颗基地选择接收卫星时都在路径长度的约束内。</p></li><li><p><strong>为什么最终的解满足路径重合约束呢？</strong></p><p>由于我们通过蚁群算法求出一个卫星集合解之后，<strong>为每座基地都是选择在集合中最邻近的接收卫星</strong>，为什么这么做就可以满足路径重合约束呢？我们在此可以做一个数学证明（非数学专业，证明过程可能不严谨，请见谅）：</p><p>假设我们得到的一个接收卫星集合{<span class="math inline">\({D_1}\)</span>,<span class="math inline">\({D_2}\)</span>},其能覆盖基地<span class="math inline">\({S_1}\)</span>、<span class="math inline">\({S_2}\)</span>，如下图所示的卫星网络连接图，<span class="math inline">\({L_1}\)</span>、<span class="math inline">\({L_2}\)</span>、<span class="math inline">\({L_3}\)</span>，<span class="math inline">\({L_4}\)</span>、<span class="math inline">\({L_5}\)</span>都大于0</p><div data-align="center"><img src="/2021/08/12/2021%E5%B9%B4%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B-%E7%AE%97%E6%B3%95%E7%BB%84/QA2.png" style="zoom:100%;"></div><p>反证法：假设<span class="math inline">\({S_1}\)</span>-&gt;<span class="math inline">\({D_1}\)</span>是从<span class="math inline">\({S_1}\)</span>出发到卫星集的最短路径，<span class="math inline">\({S_2}\)</span>-&gt;<span class="math inline">\({D_2}\)</span>是从<span class="math inline">\({S_2}\)</span>出发到卫星集的最短路径，则</p><p><span class="math inline">\(\begin{equation} \left\{  \begin{array}{lr}  {L_1}+{L_2}+{L_3}\leq{L_1}+{L_5}, &amp; \\  {L_4}+{L_2}+{L_5}\leq{L_3}+{L_4}, &amp;  \end{array} \right. \end{equation}\)</span></p><p>联立上式解的：<span class="math inline">\({L_2}\leq0\)</span>，又因为<span class="math inline">\({L_2}&gt;0\)</span>,与假设相违背。</p><p>所以<span class="math inline">\({S_1}\)</span>-&gt;<span class="math inline">\({D_1}\)</span>，<span class="math inline">\({S_2}\)</span>-&gt;<span class="math inline">\({D_2}\)</span>不同时为各自的最短路径，因此满足路径长度约束。</p></li><li><p><strong>复赛和决赛的策略如何？</strong></p><p>复赛和决赛中分别新增了一项约束条件：</p><ul><li>复赛赛题在初赛基础上加入了发射基站功耗系数限制</li><li>决赛赛题在复赛基础上加入了站点功耗约束</li></ul><p>总的来说，复赛和决赛赛题加入的约束并没有非常大的影响我们的解题模型，我们根据新添加的约束调整蚁群算法搜寻接收卫星集合解的策略，蚁群算法中的启发函数具有很大的灵活性，可以通过修整启发函数计算方法来使蚂蚁感知作出有利的选择，例如在复赛中，对于加入的基站功耗系数Csite，我们可以将其视作若新覆盖此座基地可以新增覆盖Csite，但是我们并没有把启发函数编写的太接近于目标函数，因为如果蚁群中每只蚂蚁都变得很“聪明”，蚁群算法就会失去发散性而很容易陷入局部最优解。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;0.前言&lt;/h2&gt;
&lt;p&gt;本文记录了正经队在2021年华为嵌入式软件大赛--算法组中的代码思路。在此比赛中解决的是星际光通信网络中的卫星位置规划问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="比赛" scheme="http://luohaoxiang.xyz/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>HEXO+github搭建自己的个人站</title>
    <link href="http://luohaoxiang.xyz/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/"/>
    <id>http://luohaoxiang.xyz/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/</id>
    <published>2021-02-23T11:00:22.000Z</published>
    <updated>2021-08-12T13:34:55.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">0.前言</h2><p>​ 如果你也在假期不甘寂寞，何不来搭建一个属于自己的个人网站，这篇文章将向你介绍如何使用HEXO框架搭建自己的个人博客网站，并且部署在Github上，并且进行相关的配置。</p><span id="more"></span><h2 id="前期准备">1.前期准备</h2><h3 id="安装git">1.1安装git</h3><p>从Git官网下载：<a href="https://link.zhihu.com/?target=https%3A//git-scm.com/download/win">Git - Downloading Package</a> 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功。安装成功后，请将你的Git与GitHub帐号绑定。</p><h3 id="安装node.js">1.2安装Node.js</h3><p>Hexo基于Node.js，Node.js下载地址：<a href="https://nodejs.org/en/download/">Download | Node.js</a> 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入<code>node -v</code>：</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/node安装成功检测.png" style="zoom:80%;"></p><p>检测npm是否安装成功,在命令行中输入<code>npm -v</code>：</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/npm安装成功检测.png" style="zoom: 80%;"></p><h3 id="安装hexo">1.3安装Hexo</h3><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。</p><p>进入创建的Blog文件夹，在此文件夹中打开命令行,使用npm命令<code>npm install -g hexo-cli</code>进行安装。</p><p>安装完成后，初始化我们的博客，输入：<code>hexo init blog</code>此时会建立一个blog的文件夹，<code>cd blog</code>进入blog 文件夹，为了检测我们的网站雏形，分别按顺序输入以下三条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new test_my_site</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>完成这些命令后，打开浏览器输入<code>http://localhost:4000/</code>，我们就可以看到建立的博客网站雏形</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/Hexo默认主题.jpg" style="zoom:80%;"></p><p>Hexo更具体的使用方法请参看 <a href="https://hexo.io/zh-cn/docs/">Hexo官网</a>。</p><h2 id="推送网站">2.推送网站</h2><p>上面我们只做到了在本地浏览，为了使网站能被更多人访问，我们需要将网站发布。</p><h3 id="github创建个人仓库">2.1Github创建个人仓库</h3><p>在此我们使用github pages服务搭建，这样做的好处有：</p><ol type="1"><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li></ol><p>点击GitHub中的New repository创建新仓库，仓库名应该为：username.github.io(此处username用你的github用户名代替)，这是<strong>固定的写法</strong>，比如我的用户名是fishjohn,因此仓库命名为fishjohn.github.io。</p><h3 id="站点绑定">2.2站点绑定</h3><p>建立好存放的仓库以后，我们需要在blog的根目录中的_config.yml进行站点配置，在此我们要注意区分根目录中的_config.yml文件和themes目录下面的_config.yml文件，后者是对网页主题内容的配置。</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/blog目录config文件.png" style="zoom:80%;"></p><p>下一步我们就将Hexo和GitHub关联起来，打开blog的根目录中的_config.yml文件，找到deploy根，将其修改成</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/deploy.png" style="zoom:80%;"></p><p>其中repo替换成你的github博客仓库地址。其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p><p><code>npm install hexo-deployer-git --save</code></p><p>这时，我们分别输入三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即<code>xxx.github.io</code>，你就会发现你的博客已经上线了，可以在网络上被访问了。</p><h2 id="绑定域名">3.绑定域名</h2><p>经过上面的操作，我们已经可以在互联网上访问到我们的博客网站了，但是却是通过<code>xxx.github.io</code>的地址，如果我们想使用自己的个性化域名，我们就要将其绑定到我们自己的域名中，这前提是我们需要有一个自己的域名。</p><h3 id="购买个人网站域名">3.1购买个人网站域名</h3><p>如果你有空闲的域名地址，直接使用即可，若没有我们可以通过阿里云或是腾讯云等网站代购自己的域名，我使用的是阿里云，进入 <a href="https://wanwang.aliyun.com/domain/">阿里云域名购买</a>选购即可，不同后缀的域名价钱也不一样，由于是个人博客需要，我选购的是.xyz的后缀，一年只需要9块钱。</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/阿里云域名.png" style="zoom: 80%;"></p><p>在注册好域名后我们进行域名的解析，进入阿里云控制台域名处，如下图，点击域名解析:</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/域名解析.png" style="zoom:80%;"></p><p>在设置解析页面，添加以下三条记录：</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/解析记录.png" style="zoom:80%;"></p><p>在此之后我们需要在Github端设置，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名<img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/仓库名称.png" style="zoom:80%;"></p><p>点击save保存。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/CHAME.png" style="zoom:100%;"></p><p>保存，命名为CNAME ，注意保存成<strong>所有文件</strong>而不是<strong>txt文件</strong>。</p><p>完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。</p><h2 id="更换主题">4.更换主题</h2><p>如果你不太喜欢原生默认的主题（大概率），那么我们可以在 <a href="https://hexo.io/themes/">主题网站</a>中更换寻找自己喜欢的主题并进行替换，我自己使用的是 <a href="https://github.com/litten/hexo-theme-yilia">Yilia主题</a>，可以查看在 <a href="http://luohaoxiang.xyz/">我的博客</a>中查看效果，找到主题后，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:litten&#x2F;hexo-theme-yilia.git</span><br></pre></td></tr></table></figure><p>这是将Yilia主题下载到blog目录的themes文件夹中。</p><p>打开<strong>站点</strong>的_config.yml配置文件，修改主题为theme里的主题的文件夹名称</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/theme设成yilia.png" style="zoom:80%;"></p><p>打开<strong>主题</strong>的_config.yml配置文件，在最顶端加入作者名称和副标题</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/site.png" style="zoom:80%;"></p><p>设置favicon(网页上栏的图标)和avatar（头像）图片位置</p><p><img src="/2021/02/23/HEXO-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99/头像标注.png" style="zoom:80%;"></p><p>还有一系列的栏目设置都可以参考 <a href="https://github.com/litten/BlogBackup">Yilia作者的博客备份</a></p><h2 id="写文章发布文章">5.写文章、发布文章</h2><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>然后输入<code>hexo new post "article title"</code>，新建一篇文章。</p><p>然后打开<code>D:\Blog\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的博客主页就能看到发布的文章啦。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;0.前言&lt;/h2&gt;
&lt;p&gt;​ 如果你也在假期不甘寂寞，何不来搭建一个属于自己的个人网站，这篇文章将向你介绍如何使用HEXO框架搭建自己的个人博客网站，并且部署在Github上，并且进行相关的配置。&lt;/p&gt;</summary>
    
    
    
    
    <category term="博客" scheme="http://luohaoxiang.xyz/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
